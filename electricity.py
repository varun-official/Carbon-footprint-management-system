# -*- coding: utf-8 -*-
"""Copy of LSTM_Electricity__3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dzM_-IFqt2cVeZecmSLIzPKWwPu9glgy
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.express as px # to plot the time series plot
from sklearn import metrics # for the evaluation
from sklearn.preprocessing import LabelEncoder,MinMaxScaler
import tensorflow as tf
import io
from sklearn.ensemble import ExtraTreesClassifier
from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import f_regression
import csv
from numpy import array
from numpy import hstack
from keras.layers import *
from keras.models import *
import math
from numpy.random import seed
import datetime
today = datetime.date.today()

seed(5)
tf.random.set_seed(1)
 
# print(seed)
# print(tf.random.set_seed)

def split_sequences(sequences, n_steps_in, n_steps_out):
	X, y = list(), list()
	for i in range(len(sequences)):
		end_ix = i + n_steps_in
		out_end_ix = end_ix + n_steps_out
		if out_end_ix > len(sequences):
			break
		seq_x, seq_y = sequences[i:end_ix, :], sequences[end_ix:out_end_ix, :]
		X.append(seq_x)
		y.append(seq_y)
	return array(X), array(y)

def createDataset(otherVar,target):
    combine=[]

    for var in otherVar.columns.tolist():
        in_seq = array(otherVar[var])
        in_seq = in_seq.reshape((len(in_seq), 1))
        combine.append(in_seq)

    in_seq = array(target)
    in_seq = in_seq.reshape((len(in_seq), 1))
    combine.append(in_seq)

    combine = tuple(combine)
    return hstack(combine)

def predictElec(df):
    df['Date'] = pd.to_datetime(df[['Year', 'Month']].assign(DAY=1))
    df.drop('Month',axis=1,inplace=True)
    df.drop('Year',axis=1,inplace=True)
    df.fillna(method='bfill',axis=0,inplace=True)

    initialDataset = df    
    y = df['y']
    X = df.drop('Date',axis=1)
    X = X.drop('y',axis=1)

    df = featureExtraction(df,y,X)
    n_steps_in, n_steps_out = 2,1

    otherVar = df.drop('y',axis=1)
    otherVar = otherVar.drop('Date',axis=1)

    dataset = createDataset(otherVar,df['y'])

    X, y = split_sequences(dataset, n_steps_in, n_steps_out)

    n_features = X.shape[2]
    model = Sequential()
    model.add(LSTM(200, activation='relu', input_shape=(n_steps_in, n_features)))
    model.add(RepeatVector(n_steps_out))
    model.add(LSTM(200, activation='relu', return_sequences=True))
    model.add(TimeDistributed(Dense(n_features)))
    model.compile(optimizer='adam', loss='mse')

    # epoch
    model.fit(X, y, epochs=400, verbose=0)

    num_prediction=70
    look_back=n_steps_out

    x = X[-1:]
    plotter=pd.DataFrame()

    num_req = n_steps_in - n_steps_out 

    plotter['Date'] = df['Date'].tail(n_steps_in + n_steps_out)
    plotter['Electricity'] = df['y'].tail(n_steps_in + n_steps_out)

    lastdate = plotter['Date'].tail(1).values[0]
    
    for i in range(num_prediction):
      
        prediction_list = model.predict(x)

        top_x = x[len(x)-1]
        bottom_x = prediction_list[i]

        req_x = np.concatenate([top_x[-num_req:],bottom_x])

        req_date = pd.date_range(start=lastdate,freq='M',periods=2)[1]
        plotter.at[i,'Date'] = req_date
        plotter.at[i,'Electricity'] = req_x[0][len(req_x[0])-1]

        lastdate = req_date
        x = np.append(x, [req_x], axis=0)
    plotter=plotter.drop(plotter.head(n_steps_in+n_steps_out).index)
    return initialDataset,plotter

def preprocess(df):
    req_columns = ['Month','Year','y','Working Hours']

    for val1 in df.columns.tolist():
        flag = 0
        for val2 in req_columns:
            if val1 == val2:
               flag=1 
               break
        if flag == 0:
           return 'Dataset incomplete'
    values = df['Working Hours']      
    df.fillna(method='bfill',axis=0,inplace=True)

    df['Working Hours'] = (df['Working Hours'] - df['Working Hours'].min()) / (df['Working Hours'].max() - df['Working Hours'].min())
    

    # code here

    return df

def featureExtraction(df,y,X):
    print(X)
    print(y)
    from sklearn.ensemble import ExtraTreesClassifier
    model = ExtraTreesClassifier()
    model.fit(X,y)
    feat_importances = pd.Series(model.feature_importances_, index=X.columns)
    req=pd.DataFrame()
    req=df

    dic_features = feat_importances.nlargest(10).to_dict()
    print(dic_features)
    for dic in dic_features:
        if dic_features[dic] > 0:
            req[dic]=df[dic]  
    return req



#feature selection



# plotter2 = predictSolar(plotter1['Date'].tail(1).values[0])
# plotter3 = predictCarbonFootprint(plotter1,plotter2,2)
# plotter2.plot(x='Date',y='Solar Power')

# plotter3.plot.bar(x='Date',y='CarbonFootprint',figsize=(13,15))