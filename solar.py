# -*- coding: utf-8 -*-
"""Solar_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g3F-QA6p9VZ0JL61ALSAbn-qCn2zHAhu
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.express as px # to plot the time series plot
from sklearn import metrics # for the evaluation
from sklearn.preprocessing import LabelEncoder,MinMaxScaler
import tensorflow as tf
import io
import csv
from numpy import array
from numpy import hstack
from keras.layers import *
from keras.models import *
import math
from numpy.random import seed
import datetime
today = datetime.date.today()

seed(2)
tf.random.set_seed(2)
 
print(seed)
print(tf.random.set_seed)

def createDataset(otherVar,target):
    combine=[]

    for var in otherVar.columns.tolist():
        in_seq = array(otherVar[var])
        in_seq = in_seq.reshape((len(in_seq), 1))
        combine.append(in_seq)

    in_seq = array(target)
    in_seq = in_seq.reshape((len(in_seq), 1))
    combine.append(in_seq)

    combine = tuple(combine)
    return hstack(combine)

def split_sequences(sequences, n_steps_in, n_steps_out):
	X, y = list(), list()
	for i in range(len(sequences)):
		end_ix = i + n_steps_in
		out_end_ix = end_ix + n_steps_out
		if out_end_ix > len(sequences):
			break
		seq_x, seq_y = sequences[i:end_ix, :], sequences[end_ix:out_end_ix, :]
		X.append(seq_x)
		y.append(seq_y)
	return array(X), array(y)

def predictSolar(lastdate,filename):
    input = open(filename, 'r')
    rowsCnt=0

    for row in csv.reader(input):
        if row[0]=="-END HEADER-":
            break
        rowsCnt+=1

    df=pd.read_csv(filename,skiprows=rowsCnt+1)    
    req=pd.DataFrame()
    attrs=set(df['PARAMETER'])

    for attr in attrs:
        req[attr]="NULL"

    for index, row in df.iterrows():  
        cnt=0
        all_months=pd.date_range(str(row[1]), periods=12, freq="MS").strftime("%D")
        for ele in row[2:-1]:
            col_name=row[0]
            req.at[all_months[cnt],col_name]=ele
            cnt+=1

    req.replace(-999, np.nan,inplace=True)
    req.fillna(method='bfill',axis=0,inplace=True)
    req.reset_index(level=0, inplace=True)
    req.rename(columns = {"index" : "Date", 'ALLSKY_SFC_SW_DWN':'y'}, inplace = True)
    df=req
    data=df.drop('Date',axis=1)
    otherVar=data.drop('y',axis=1)
    target = data['y']

    dataset = createDataset(otherVar,target)
    n_steps_in, n_steps_out = 3,2
    X, y = split_sequences(dataset, n_steps_in, n_steps_out)

    
    n_features = X.shape[2]
    model = Sequential()
    model.add(LSTM(200, activation='relu', input_shape=(n_steps_in, n_features)))
    model.add(RepeatVector(n_steps_out))
    model.add(LSTM(200, activation='relu', return_sequences=True))
    model.add(TimeDistributed(Dense(n_features)))
    model.compile(optimizer='adam', loss='mse')
    model.fit(X,y,epochs=300,verbose=0)
    months = pd.date_range(start = df['Date'].tail(n_steps_out+n_steps_in).values[0],end = lastdate,freq='M')
    itr = len(months)
    look_back=n_steps_out

    x = X[-1:]
    plotter=pd.DataFrame()

    num_req = n_steps_in - n_steps_out 
    plotter['Date'] = df['Date'].tail(n_steps_in + n_steps_out)
    plotter['Solar power'] = df['y'].tail(n_steps_in + n_steps_out)
    lastdate = plotter['Date'].tail(1).values[0]
    
    for i in range(itr):
      
        prediction_list = model.predict(x)
        top_x = x[len(x)-1]
        bottom_x = prediction_list[i]
        req_x = np.concatenate([top_x[-num_req:],bottom_x])
        req_date = pd.date_range(start=lastdate,freq='M',periods=2)[1]
        plotter.at[i,'Date'] = req_date
        plotter.at[i,'Solar power'] = req_x[0][len(req_x[0])-1]
        lastdate = req_date
        x = np.append(x, [req_x], axis=0)

    plotter=plotter.drop(plotter.head(n_steps_in+n_steps_out).index)
    return plotter